一、CSS
1.说一下css的盒模型。
    在HTML页面中的所有元素都可以看成是一个盒子盒子的组成:
    内容content、内边距padding、边框border、外边距margin
    盒模型的类型:
    标准盒模型
    margin + border + padding + content
    IE盒模型
    margin +content(border+padding)
    控制模型的模式:box-sizing:content-box(默认值，标准盒模型)、border-box(IE盒模型);

2.csS选择器的优先级?
    CSS的特性:继承性、层叠性、优先级
    优先级:写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式
    标签、类/伪类/属性、全局选择器、行内样式、id、!important
    !important >行内样式 >id >类/伪类/属性 >标签 >全局选择器

3.隐藏元素的方法有哪些?
    1.display:none;
    2.元素在页面上消失，不占据空间opacity:0;
    3.设置了元素的透明度为8，元素不可见，占据空间位置visibility:hidden;
    4.让元素消失，占据空间位置，一种不可见的状态position:absolute;
    5.clip-path

4.px和rem的区别是什么?
    px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度
    rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;
    1rem = 10px;(16px*62.5%=10px)

5.重绘重排有什么区别?
    重排(回流):布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小
    重绘:计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制浏览器的渲染机制
    对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排
    对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘

6.让一个元素水平垂直居中的方式有哪些?
    1.定位+margin
    2.定位+transform
    3.flex布局
    4.grid布局
    5.table布局

7.css的哪些属性哪些可以继承?哪些不可以继承?
Css的三大特性:维承、层叠、优先   子元素可以维承父类元素的样式
    1.字体的一些属性:font
    2.文本的一些属性:1ine-height
    3.元素的可见性:visibslity:hidden
    4.表格参局的属性:border-spacing
    5.列表的属性:list-style
    6.页面样式战性:Page
    7.声音的样式属性

8.有没有用过预处理器?
    预处理语言增加了变量、函数、混入等强大的功能
    SASS LESS

9.清除浮动
    1.额外标签法
    浮动元素之后添加一个空div或其他块级元素，并设置clear:both
    2.使用overflow属性触发BFC
    浮动元素的父容器上设置:overflow:hidden
    3.伪元素清除法
    利用:after伪元素为浮动元素的父容器添加看不见的内容，然后设置:clear:both; display:block; content:''
    4.直接设置高度

10.BFC
    块级格式化上下京浏览器在渲染过程中用于组织块级元素的一个独立渲染区域触发BFC的条件:
        1.float值不为None的元素
        2.position的值为absolute/fixed的元素
        3.display值为inline-block/table-cell/table-caption/grid/flex等非默认块级显示模式的元素
        4.overflow值不是visible的块级元素
    解决问题:
        1.外边距合并
        2.浮动元素的影响
        3.文字环绕效果
        4.防止外边距穿透


二、JavaSscipt & ES6
1.JS由哪三部分组组成?
    ECMAScript;Js的核心内容，播述了语言的基础语法。比如var,for,数据类型(数组、字符)
    文档对象模型(DOM):DOH把整个Html页面规划为元素构成的文档
    浏览器对象模形(B0M):对浏览器窗口进行访问和操作

2.JS有曝些内置对象?
    String Boolean Number Array object Function Math Date RegExp...
    Math
        abs()sqrt()max()min()
    Date
        new Date() getYear()
    Array
        String
    concat()length slice()split()

3.操作数组的方法有哪些?
    push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter() 
    ervery() some() reduce() isArray() findIndex() join() 
    哪些方法会改变原数组:
        push()pop()unshift()shift()sort()reverse()splice() fill()

4.JS对数据类的检测方式有哪些?
    typeof   
        typeof 'a'
    instanceof()   
        'a' instanceof String
    constructor  
        ('a').constructor === String
    Object.prototype.tostring.call()  
        let opt = Object.prototype.toString; 
        console.log(opt.call('a'))

5.说一下闭包，闭包有什么特点?
    什么是闭包?
        函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包
        当一个函数被定义并在其外部作用域中有自由变量时，若该函数作为值被返回或者被赋值给一个变量，那么即使在其外部作用域结束后，该函数仍能继续访问并改变这些自由变量，那么这样的函数连同其所访问的外部变量环境一起形成了闭包
    特点:
        可以重复利用变量，并日这个变量不会污染全局的一种机制:这个变量是一直保存再内存中，不会被垃圾回收机制回收
    缺点:
        闭包较多的时候，会消耗内存，导致页面的性能下降，页面加载缓慢
        在IE浏览器中才会导致内存泄漏
    使用场景:
        防抖，节流，函数嵌套函数避免全局污染的时候
        数据封装和私有变量
        函数工厂和函数柯里化
        事件处理和异步编程
        缓存机制

6.前端的内存泄漏怎么理解?
    JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
    程序中已不再需要的对象或变量，无法被垃圾回收机制识别并释放。从而持续占有系统内存的现象原因:
        1.长期持有内部变量的引用
            一些为生命直接赋值的变量;
            一些未清空的定时器;
            一些引用元素没有被清除。
        2.循环引用
            过度的闭包;
    解决:
    1.适时接触引用
    2.合理设计闭包的生命周期
    3.弱引用
    4.使用现在浏览器提供的工具检查内存泄露

7.事件委托是什么?
    又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上如果子元素组织了事件冒泡，那么委托也就不成立
    阻止事件冒泡:event.stopPropagation() 
    addEventListener('click',函数名，true/false)默认是false(事件冒泡)，true(事件捕获)
    好处:提高性能，减少事件的绑定，也就减少了内存的占用。

8.基本数据类型和引用数据类型的区别?
    基本数据类型:string Number Boolean undefined null
    基本数据类型保存在栈内存当中，保存的就是一个具体的值
    引用数据类型(复杂数据类型):object Function Array保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址
    假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变

9.说一下原型链。
    原型:
        .prototype, Js中每个函数的内置属性，它指向一个对象，对于构造函数来说，他的prototype属性指向的对象就是构造函数生成的新对象实例的原型对象
    实例原型:._proto_, 可以理解为指针，实例对象中的属性，指向了构造函数的原型
    原型对象:
        存储了可以被实例共享的方法和属性，每当尝试访问一个属性自身的实例和方法时，如果实例自身没有，则会自动去它的原型对象中查找,
    原型链：
        查找机制，它是Js中对象属性和方法继承的基础
        当我们试图访问一个对象的属性或方法时，如果该对象本身没有定义这个属性或方法，JS引擎会沿着原型链逐层向上查找，即先查找实例的原型，如果原型中未找到，则继续查找原型的原型，直到找到该属性和方法，或者抵达原型连的顶端，也就是null

10.new操作符具体做了什么?
    1.内存分配
        先创建一个空对象
    2.构造函数调用
        把空对象和构造函数通过原型链进行链接
    3.this绑定
        把构造函数的this绑定到新的空对象身上
    4.返回新对象
        根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型
<!-- 
    function newFun(Fun,...args){
    let newobi={}
    newobj.proto =Fun.prototype
    const result= Fun.apply(newobj,args)
    return result instanceof obiect ? result : newobj
    }

    function Person(name){ this.name = name }
    Person.prototype.say=function(){ console.log('123456') }
    const p1 = newFun(Person,'张三')
    p1.say()
    console.log(p1)
 -->

11.JS是如何实现继承的?
    1.原型链继承
    function Parent(){}
    Parent.prototype.value='父值'
    function Child(){}
    Child.prototype = Object.create(Parent.prototype)
    Child.prototype.constructor = Child
    let child = new Child()

    2.借用构造函数继承
    function Parent(name){
        this.name = name
    }
    function Child(name,age){
        Parent.call(this, name)
        this.age = age
    }
    

    3.组合式继承
    function Parent(name){
        this.name = name
    }
    Parent.prototype.sayName = function(){
        console.log(this.name)
    }
    function Child(name,age){
        Parent.call(this, name)
        this.age = age
    }

    4.ES6的class类继承
    class Parent{
        constructor(name){
            this.name = name
        }
    }
    class Child extends Parent{
        constructor(name, age){
            super(name)
            this.age = age
        }
    }

12.Js的设计原理是什么?
JS引擎 运行上下文 调用栈 事件循环 回调

13.Js中关于this指向的问题
    <!-- 1.全局对象中的this指向  指向的是window
    2.全局作用域或者普通函数中的this  指向全局window
    3.this永远指向最后调用它的那个对象  在不是箭头函数的情况下
    4.new 关键词改变了this的指问
    5.apply,call,bind  可以改变this指向，不是箭头函数
    6.箭头函数中的this
        它的指向在定义的时候就已经确定了
        箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window
    7.匿名函数中的this
        永远指向了window,匿名函数的执行环境具有全局性，因此this指向window -->
    1.全局作用域或普通函数
        当函数在全局作用域下执行，或者以常规函数调用的话，this指向全局对象window
    2.对象方法调用
        当函数作为对象的一个方法被调用时，this指向调用该方法的对象本身
    3.构造函数调用
        在构造函数内部，this指向正在被创建的新对象实例
    4.内置函数及事件处理函数
        在JS内置函数或DOM事件处理函数中，this可能指向调用这些函数的特定上下文
        比如event事件触发上下文
    5.函数上下文的强制绑定
        通过call apply bind等方法，可以主动改变函数执行时this的指向，让他指向任意指定的对象
    6.箭头函数
        自身没有this，继承父级作用域的this

14.script标签里的async和defer有什么区别?
    当没有async和defer这两个属性的时候，
        浏览器会立刻加载并执行指定的脚本
    有async
        加载和渲染后面元素的过程将和script的加载和执行并行进行(异步)有defer
        加载和渲染后面元素的过程将和script的加载并行进行(异步)，但是它的执行事件要等所有元素解析完成之后才会执行

15.setTimeout最小执行时间是多少?
HTML5规定的内容:
    setTimeout最小执行时间是4ms
    setInterval最小执行时间是10ms

16.ES6和ES5有什么区别?
JS的组成:ECMAScript BOM DOM
ES5:ECMAScript5,2009年ECMAScript的第五次修订,ECMAScript2009
ES6:ECMAScript6,2015年ECMAScript的第六次修订,ECMAScript2015,是Js的下一个版本标准

17.ES6的新特性有哪些?
    1.新增块级作用域(let,const)
        不存在变量提升
        存在暂时性死区的问题
            从变量的创建到语法绑定之间这一段空间，由于此时还未完成语法绑定，如果我们访问或使用该变量，就会产生暂时性死区的问题
        块级作用域的内容
        不能在同一个作用域内重复声明
    2.新增了定义类的语法糖(class)，在面向对象变成更加清晰和理解
    3.新增了一种基本数据类型(symbol)
    4.新增了解构赋值 
        简化数据交换过程
    5.新增了函数参数的默认值
    6.给数组新增了API
    7.对象和数组新增了扩展运算符  在函数调用，数组构造，合并数组和对象，实现浅拷贝
    8.Promise  处理异步机制提供了标准化的链式调用和错误处理机制，是实现异步流程的重要处理工具
    Promise作为一个对象，代表未来的某个时刻可能完成的异步操作记录，并提供了统一的api来处理成功或失败的情况
        解决回调地狱的问题
        自身有all， reject, resolve, race方法
        原型上有then, catch方法
        三种状态pending初始状态, fulfilled操作成功, rejected操作失败
        两种变化，pending到fulfilled，pending到rejected
        async awiat
            同步代码做异步的操作，两者必须搭配使用
            async表明函数内有异步操作，调用函数会返回promise
            await是组成async的表达式，结果是取决于它等待的内容
            如果是promise那就是promise的结果
            如果是普通函数就进行链式调用
        await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行
    9.新增了模块化(import,export)
    10.新增了set和map数据结构  推动js易用性
        set就是不重复
        map的key类型不受限制
    11.新增了generator
    12.新增了箭头函数
        不能作为构造函数使用，不能用new箭头函数就没有原型
        箭头函数没有arguments
        箭头函数不能用call,apply,bind去改变this的执行this指向外层第一个函数的this
    13.模版字符串，用反引号包裹多行字符串，支持插值表达式，便于格式化和拼接
    14.迭代器和生成器，迭代器提供统一访问集合元素的方法，生成器是特殊的迭代器，可以暂停和恢复执行，让异步编程更加灵活

18.call,aply,bind三者有什么区别?
    都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同call: 传的是一个参数列表
        允许你调用一个函数，并将调用上下文设置为指定的对象，同时可以直接传递参数
    apply: 传递的是一个数组或类数组
        用于更改函数调用时的上下文并执行函数，但函数传递的形式不同
    bind:
        不会立即调用，而是创建一个新的函数实例，这个新函数始终保持了对原函数的引用，可以传参，并且拥有预设this值，同时可以预设部分参数

    bind()() 两个括号才能调用，不能做构造函数，适用于永久改变上下文并在多个场合反复调用的情况
    call方法的性能要比apply好一些，所以call用的更多一点，都是临时改变上下文

19.用递归的时候有没有遇到什么问题?
    如果一个函数内可以调用函数本身，那么这个就是递归函数函数内部调用自己
    特别注意:写递归必须要有退出条件return

20.浅拷贝和深拷贝?
    浅拷贝：
        把源对象的所有属性赋值过来
    深拷贝
        完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响，主要针对的是引用数据类型
    1.扩展运算符
        缺点:这个方法只能实现第一层，当有多层的时候还是浅拷贝
    2.JSON.parse(JSON.stringify())
        缺点:这个方法只能实现第一层，当有多层的时候还是浅拷贝
    3.利用递归函数实现

21.说一下事件循环。
    JS是一个单线程的脚本语言主线程执行栈任务队列 宏任务 微任务
    主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务
    全部执行完之后等待主线程的调用，调用完之后再去任务队列中査看是否有异步任务，这样一个循环往复的过程就是事件循环

    任务队列
        程序把所有的任务放入到不同的任务队列中，同步任务立即执行，一步任务则在其完成时被挂起，等待处理
    事件触发
        当一个异步任务完成的时候，它并不会立即执行，而是生成一个事件并将其推入到事件队列事件循环程序有一个不断循环监测的任务，它会不断的检査事件队列，一旦发现有事件等待处理，那么就会从队列中取出事件，并调用对应的回调函数进行执行
    微任务和宏任务
        微任务队列和宏任务队列，微任务会在当前宏任务执行结束后立即执行， 而新的宏任务则需要等待下一次的事件循环

22.ajax是什么?怎么实现的?
    创建交互式网页应用的网页开发技术
        在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容
    通过xmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面
    1.创建XmlHttpRequest对象 xmh
    2.通过xmh对象里的open()方法和服务器建立连接
    3.构建请求所需的数据，并通过xmh对象的send()发送给服务器
    4.通过xmh对象的onreadystate change事件监听服务器和你的通信状态
    5.接收并处理服务器响应的数据结果
    6.把处理的数据更新到HTML页面上

23.get和post有什么区别?
    1.get一般是获取数据，post一般是提交数据
    2.get参数会放在ur1上，所以安全性比较差，post是放在body中
    3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
    4.get请求时会被缓存,post请求不会被缓存
    5.get请求会被保存在浏览器历史记录中,post不会
    6.get请求只能进行url编码，post请求支持很多种

24.promise的内部原理是什么?它的优缺点是什么?
    Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果
    Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系,就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差
    有三种状态:pending初始状态 fulfilled成功状态 rejected失败状态
    状态改变只会有两种情况
        pending ->fulfilled; pending ->rejected 
    一旦发生，状态就会凝固，不会再变
    首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消
    如果不设置回调，promise内部抛出的错误就无法反馈到外面
    若当前处于pending状态时，无法得知目前在哪个阶段。
    原理:
        构造一个promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject
        promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数

25.promise和async await的区别是什么?
    1.都是处理异步请求的方式
    2.promise是ES6，async await是ES7的语法
    3.async await是基于promise实现的，他和promise都是非阻塞性的
    优缺点:
    1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过try catch进行捕获异常
    2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作
    promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作 

26.浏览器的存储方式有哪些?
    1.cookies
        H5标准前的本地存储方式
        兼容性好，请求头自带cookie
        存储量小，资源浪费，使用麻烦(封装)
    2.localstorage
        H5加入的以键值对为标准的方式
        操作方便，永久存储，兼容性较好保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫
    3.sessionstorage
        浏览器关闭后就会立刻清理，会话级别的存储方式
    4.indexedDB
        H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景

27.token存在sessionstorage还是loaclstorage?
    token:验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串
    1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台
    2.存cookie中，会自动发送，缺点就是不能跨域
    如果存在localstorage中，容易被xss攻击，但是如果做好了对应的措施，那么是利大于弊
    如果存在cookie中会有CSRF攻击

28.token的登录流程。
    1.客户端用账号密码请求登录
    2.服务端收到请求后，需要去验证账号密码
    3.验证成功之后，服务端会签发一个token，把这个token发送给客户
    4.客户端收到token后保存起来，可以放在cookie也可以是localstorage
    5.客户端每次向服务端发送请求资源的时候，都需要携带这个token
    6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据

29.页面渲染的过程是怎样的?
    DNS解析
    建立TCP连接
    发送HTTP请求
    服务器处理请求
    渲染页面
        浏览器会获取HTML和cSs的资源，然后把HTML解析成DOM树
        再把css解析成CSSOM
        把DOM和CSSOM合并为渲染树
        重排
        布局
        把渲染树的每个节点渲染到屏幕上(绘制)
        重绘
    断开TCP连接

30.DOM树和渲染树有什么区别?
    DOM树是和HTML标签一一对应的，包括head和隐藏元素渲染树是不包含head和隐藏元素

31.精灵图和base64的区别是什么?
    精灵图:把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度
    base64:传输Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。

32.svg格式了解多少?
    基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SvG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真
    1.SVG可直接插入页面中，成为DOM一部分，然后用JS或cSS进行操作
      //  <svg></svg>
    2.SVG可作为文件被引入
    // <img src="pic.svg" />I
    3.SVG可以转为base64引入页面

33.了解过JWT吗?
    JsoN web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
    信息传输、授权
    JWT的认证流程
    1.前端把账号密码发送给后端的接口
    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT(token)。
    3.前端每次请求时都会把JWT放在HTTP请求头的Authorization字段内
    4.后端检査是否存在，如果存在就验证JWT的有效性(签名是否正确，token是否过期)
    5.验证通过后，后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。

34.npm的底层环境是什么?
    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境
    npm的组成:网站、注册表、命令行工具

35.HTTP协议规定的协议头和请求头有什么?
    1.请求头信息:
        Accept:浏览器告诉服务器所支持的数据类型
        Host:浏览器告诉服务器我想访问服务器的哪台主机
        Referer:浏览器告诉服务器我是从哪里来的(防盗链)
        User-Agent:浏览器类型、版本信息
        Date:浏览器告诉服务器我是什么时候访问的
        Connection:连接方式
        Cookie
        X-Request-with:请求方式
    2.响应头信息:
        Location:这个就是告诉浏览器你要去找谁
        Server:告诉浏览器服务器的类型
        Content-Type:告诉浏览器返回的数据类型
        Refresh:控制了的定时刷新

36.说一下浏览器的缓存策略。
    强缓存(本地缓存)、协商缓存(缓存)
    强缓:不发起请求，直接使用缓存里的内容，浏览器把js，css，image等存到内存中，下次用户访问直接从内存中取，提高性能
    协缓:需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回384，浏览器就用缓存里的内容
    强缓存的触发:
    HTTP1.0:时间戳响应标头
    HTTP1.1:cache-control响应标头
    协商缓存触发:
    HTTP1.0:请求头:if-modified-since 响应头:last-modifiedHTTP1.1:请求头:if-none-match 响应头:Eag

37.说一下什么是“同源策略”?
    http:/www.  aaa.com:8080/index/vue.js
    协议 子域名 主域名   端口号   资源  
    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域
    三个允许跨域加载资源的标签: img   link   script
    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了!
    JSONP
    CORS
    websocket
    反向代理

38.防抖和节流是什么?
    都是应对页面中频繁触发事件的优化方案
    防抖:避免事件重复触发，在用户停止触发事件一段时间后，再执行对应的函数。
        使用场景:1.频繁和服务端交互 2.输入框的自动保存事件
    节流:把频繁触发的事件减少,每隔一段时间执行。在一定时间内，不管事件出发多么频繁，函数只执行一次
        使用场景:scroll事件

39.解释一下什么是json?
    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输
    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、cookie中
    JS提供了JSON.parse()JsoN.stringify()
    什么时候使用json:定义接口;序列化;生成token;配置文件package.json

40.当数据没有请求过来的时候，该怎么做?
    可以在渲染数据的地方给一些默认的值
    if判断语句

41.有没有做过无感登录?
    1.在相应其中拦截，判断token返回过期后，调用刷新token的接口
    2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口
    3.写定时器，定时刷新token接口
流程:
    1.登录成功后保存token和refresh token
    2.在响应拦截器中对401状态码引入刷新token的api方法调用
    3.替换保存本地新的token
    4.把错误对象里的token替换
    5.再次发送未完成的请求
    6.如果refresh toker过期了，判断是否过期，过期了就清楚所有token重新登录

42.大文件上传是怎么做的?
    分片上传:
    1.把需要上传的文件按照一定的规则，分割成相同大小的数据块
    2.初始化一个分片上传任务，返回本次分片上传的唯一标识
    3.按照一定的规则把各个数据块上传
    4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件
    断点续传:
    服务端返回，从哪里开始浏览器自己处理

43.作用域和作用域链
    作用域
        作用域就是一个变量或函数在其内能够被访问的“可见区域”全局作用域、局部作用域
    作用域链
        当在某个作用域中尝试访问一个变量时，JS引擎会从当前作用域开始，沿着作用域链向上逐级查找直到找到该变量为止，如果在全局作用域仍然找不到，则抛出未定义错误
    
    let val = "全局"
    function outer(){let out = '外部'， function inner(){
        console.log(val), console.log(out)
        } inner()}
    outer()

44.什么是面向对象编程
    0OP，在于模拟现实世界的实体和其他相关的联系，通过创建对象并利用对象之间的交互，来解决问题
    1.抽象性
        从复杂事物中提炼出关键特性和行为的过程，表现为定义类
    2.封装性
        把数据和对数据的操作捆绑在一个对象内，对外隐藏内部实现细节，既保护了数据安全，又简化了外部对对象的使用，直接调用公用接口进行交互，避免了直接修改内部状态带来的风险
    3.继承性
        允许子类从父类那里继承已有的属性和方法，避免重复编写相同代码。子类不仅包含父类所有的属性和方法，而且可以拓展自己的属性和方法，从而实现代码复用，并形成了类的层次结构
    4.多态性
        同一接口可以表示多种形态或类型的行为。
        参数多态：
            不同类型对象对同一方法的响应各不相同
        方法重载：
            在同一类中，定义同名的的不同方法，根据传入的参数，类型，数量决定调用哪种方法

45 微任务和宏任务
    每当主线程执行完一个宏任务后，它不会立即执行下一个宏任务而是接着先检查微任务队列
        如果微任务队列中存在待执行的任务
        主线程会立即执行微任务，直到微任务队列为空
        因为微任务通常包含那些需要在当前逻辑上下文结束后、但在渲染或执行新的宏任务之前必须完成的操作
    微任务:promsie回调mutationobserver变动记录，
    操作性质决定他们应该快速且优先被执行，来确保数据的统一和更快响应程序状态的变化
    宏任务:ajax请求、定时器..

46.什么是高阶函数，有什么使用场景
    特征:
    1.接受一个或多个函数作为输入参数，这些函数就是回调函数
    2.返回一个新函数，这个新函数有可能就是原函数操作的结果，也可能是封装了输入函数的某种行为模式
    场景:
    映射:Array.prototype.map()
    过滤Array.prototype.filter()
    规约 reduce
    排序 sort
    函数工厂
    柯里化
    事件处理和异步编程

47.箭头函数和普通函数的区别
    1.语法
    2.this绑定
        箭头函数:没有自己的this上下文，而是继承父类的this普通函数:this取决于函数的调用方式
    3.arguments对象
        箭头:不包含arguments对象
        普通:包含arguments对象
    4.原型和构造函数
        箭头:由于不能绑定this,且没有自己的prototype,所以不能作为构造函数，也不能使用new
        普通:有this,可以使用new
    5.作用域和闭包
        箭头:遵循作用域规则
        普通:形成闭包

48.ES6如何改进类的定义和继承机制
    1.类的定义
    class Person(name){
        constructor(name){
            this.name = name
        }
        sayhi(){
            console.log('hi')
        }
    }

    2.类的继承
    class Student extends Person{
        constructor(name){
            super(name)
        }
        childself( ){
            console.sayhi()
        }
    }
    3.方法和属性修饰符
        静态方法和属性
        getter/setter
    4.类表达式和类字段初始化
    5.更严格的私有成员

49.Promise如何处理异步操作
    Promise是处理异步机制提供了标准化的链式调用和错误处理机制，是实现异步流程的重要处理工具
    Promise作为一个对象，代表未来的某个时刻可能完成的异步操作记录，并提供了统一的api来处理成功或失败的情况
    1.状态和决议
        三种状态
        两张结果
    2.链式调用
        .then()处理链式异步任务，每个.then方法接受两个回调函数，分别对应异步操作成功或失败的状态。成功的回调函数接受前一个promise决议的结果，失败的回调函数处理异常情况
    3.错误处理
        .catch()捕获整个promise链中任一环节的错误
    4.并发控制
    .a11()处理多个promise，全部成功则返回成功，如果有一个失败，则进入失败状态
    .race()任何一个promise先改变状态，那么整个promise就进入相应的状态
    5.异步资源清理
    finnaly

50.Map和Set各自的特性
    Map
        键值对的集合，允许任何类型的值作为键键值对存储
        自动排序
        易于查找和更新
        内置size属性
        let myMap = new Map()
        myMap.set('name','zhangsan')
        console.log(myMap.get('name'))
    Set
        唯一值的集合，不允许有重复的值保证唯一性
        自动排序
        遍历和操作
        内置size属性
        let mySet = new set()
        myset.add('apple')
        mySet.add('apples')
        mySet.has('apple')//true

51.解构赋值
    1.数组解构
    let [a,b,c]= arrconsole.log( a,b,c )
    let [first,,third]= arrconsole.log( first,third )
    let [one='default',two, ,]= [1]console.log( one )
    let [d,...e]= arrconsole.log(d,e)
    2.对象的解构赋值
    let obj ={name:'张三', age:'18', job:'teacher'}
    let {name,age} = objconsole.log( name,age )

52.扩展运算符合并数组和对象
    提供了一种简洁而实用的放大，极大简化了数组和对象赋值和合并的过程，提高编程效率
    1.数组
    let arr = [1,2,3]
    let arr1 =[...arr]
    console.log( arr1 )
    let arr2 = [1,2]
    let arr3 = [3,4]
    let arr4 = [...arr2,...arr3]
    console.log( arr4 )
    2.对象
    let obj = {a:1,b:2}
    let obj1 ={...obj}
    console.log( obj1 )
    let obj2 ={a:1,b:2}
    let obj3 = {c:3,d:4}
    let obj4 ={...obj2,...obj3}
    console.log(obj4 )

53.遍历数组方法
    1.for..of
    let fruits = ['apple','banana','cherry']
    for( let fruit of fruits ){console.log( fruit )}
    2.forEach()
    fruits.forEach((fruit,index,arr)=>{console.log( `${index}:${fruit}`)
    })
    3.map()
    let ufruit = fruits.map(fruit => fruit.toUppercase())
    console.log( ufruit )
    4.filter
    let yellowFruit =fruits,filter(fruit =>fruit === 'banana')
    console.log(yellowFruit )


三、HTML5 & CSS3
1.语义化的理解。I
    在写HTML页面结构时所用的标签有意义
    头部用head 主体用main 底部用foot...
    怎么判断页面是否语义化了?
    把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常为什么要选择语义化?
    1.让HTML结构更加清晰明了
    2.方便团队协作，利于开发
    3.有利于爬虫和SEO
    4.能够让浏览器更好的去解析代码
    5.给用户带来良好的体验

2.Html5 C3有哪些新特性?
H5的新特性:
    1.语义化的标签
    2.新增音频视频
    3.画布canvas，SVG
    4.数据存储localstorage sessionstorage
    5.增加了表单控件 email url search time...
    6.拖拽释放API
    7.web Worker, webSocket
    8.离线存储
CsS3的新特性:
    1.新增选择器:属性选择器、伪类选择器、伪元素选择器
    2.增加了媒体查询
    3.文字阴影
    4.边框
    5.盒子模型box-sizing
    6.渐变
    7.过度
    8.自定义动画
    9.背景的属性
    10.2D和3D

3.rem是如何做适配的?
    rem是根据根元素fent-size计算值的倍数
    rem是相对长度，相对于根元素(htm1)的font-size属性来计算大小，通常来做移动端的适配
    比如html上的font-size:16px，给div设置宽为1.2rem, 1.2rem = 16px*1.2 = 19.2px

4.解决了哪些移动端的兼容问题?
    1.当设置样式overflow:scroll/auto时，iOS上的滑动会卡顿
        -webkit-overflow-scrolling:touch;
    2.在安卓环境下placeholder文字设置行高时会偏上
        input有placeholder属性的时候不要设置行高
    3.移动端字体小于12px时异常显示
        应该先把在整体放大一倍，然后再用transform进行缩小
    4.ios下input按钮设置了disabled属性为true显示异常
        input[type=button]{opcity:1}
    5.安卓手机下取消语音输入按钮
        input::-webkit-input-speech-button{display:none}
    6.IOS下取消input输入框在输入英文首字母默认大写
        <input autocapitalize='off' autocorrect='off'/>
    7.禁用iOS和安卓用户选中文字
        添加全局CsS样式:-webkit-user-select:none
    8.禁止IOS弹出各种窗口
        -webkit-touch-callout:none
    9.禁止IOS识别长串数字为电话
        添加meta属性 <meta conten='telephone=no' name='format-detection'>

5.如何实现自适应视频
    无限适配方案 + rem单位
    无限适配方案
    把屏幕划分为一定的份数(10份)，通过JS动态监测屏幕尺寸宽度，实时计算并设置htm1元素的基础字体大小

    假设设计稿基准宽度为750px，将屏幕宽度逻辑上分成10等份
    function applyTaobaoAdaptive(){
    const docEl= document.documentElement;
    const baseWidth =750;
    const winWidth =docEl.clientwidth
    window.innerWidth:const onePart
    width=winwidth /10;
    docEl.style.fontsize =onePartWidth+'px';// 动态设置html基础字体大小，实时更新适配
    }
    监听窗口大小变化，
    window.addEventListener('resize', applyTaobaoAdaptive),applyTaobaoAdaptive();

四、vue
1.v-if和v-show的区别?
    都可以控制元素的显示和隐藏
    1.v-show时控制元素的display值来让元素显示和隐藏;v-if显示隐藏时把DOM元素整个添加和删除
    2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件;v-show只是简单的css切换
    3.v-if才是真正的条件渲染;v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期
    4.v-if的切换效率比较低 v-show的效率比较高

2.如何理解MVVM的?
    是Model-View-ViewModel的缩写。前端开发的架构模式
    M:模型，对应的就是data的数据
    V:视图，用户界面，DOM
    VM:视图模型:vue的实例对象，连接view和Model的桥梁
    核心是提供对View和ViewMode1的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图。当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为它是由MVVM统一管理

3.v-for中的key值的作用是什么?
    key属性是DOM元素的唯一标识作用:
    1.提高虚拟DOM的更新
    2.若不设置key，可能触发一些bug
    3.为了触发过渡效果

4.说一下你对vue生命周期的理解,
    组件从创建到销毁的过程就是它的生命周期
    创建
    beforecreat
        在这个阶段属性和方法都不能使用
        这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图
    created
    挂载
    beforeMount
        完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated
    Mounted
        把编译好的模板挂载到页面，这里可以发送异步请求也可以访问D0M节点
    更新
    beforeUpdate
        组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据
    updated
        render重新做了渲染，这时数据和页面都是新的，避免在此更新数据
    销毁
    beforeDestroy
        实例销毁前，在这里实例还可以用，可以清除定时器等等
    destroyed
        组件已经被销毁了，全部都销毁使用了
    keep-alive时多出两个周期:
    activited
        组件激活时
    deactivited
        组件被销毁时

5.在created和mounted去请求数据，有什么区别?
    created:在渲染前调用，通常先初始化属性，然后做渲染
    mounted:在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作
    在这里请求数据可能会出现闪屏的问题，created里不会
    一般用created比较多
    请求的数据对DOM有影响，那么使用created
    如果请求的数据对DOM无关，可以放在mounted

6.vue中的修饰符有哪些?
    1.事件修饰符
    .stop       阻止冒泡
    .prevent    阻止默认行为
    .capture    内部元素触发的事件先在此处理
    .self       只有在event.target是当前元素时触发
    .once       事件只会触发一次
    .passive    立即触发默认行为

    .native     把当前元素作为原生标签看待
    2.按键修饰符
    .keyup      键盘抬起
    .keydown    键盘按下
    3.系统修饰符
    .ctrl
    .alt
    .meta
    4.鼠标修饰符
    .left       鼠标左键
    .right      鼠标右键
    .middle     鼠标中键
    5.表单修饰符
    .lazy       等输入完后显示
    .trim       删除内容前后的空格
    .number     输入是数字或转化为数字

7.elementui是怎么做表单验证的?
    1.在表单中加rules属性，然后再data里写校验规则
    2.内部添加规则
    3.自定义函数校验

8.vue如何进行组件通信?
    1.父传子
    props
        父组件使用自定义属性，然后子组件使用props
    $ref
        引用信息会注册在父组件的$refs对象上
    2.子传父
    $emit
        子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数
    3.兄弟传
        new一个新的vue实例，用on和emit来对数据进行传输
    4.vuex传值

9.keep-alive是什么?怎么使用?
    vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们
    作用:把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验
    1. 缓存所有页面  App.vue里面
    2. 根据条件缓存页面 设置include,里面name可以是组件名,正则（v-bind）,动态判断,exclude
    3. 结合router缓存部分页面
    在children设置meta: {keepAlive：true/false}
    在页面里面设置v-if判断,$router。meta.keepAlive

10.axios是怎么做封装的?
    下载 创建实例 接着封装请求响应拦截器:抛出 最后封装接口

11.vue路由时怎么传参的?
    params传参（不会再url中显示）
        this.$router.push({
            name:"index', 
            params:{
                id:item.id}
                })
        this.$route.params.id
    
    路由属性传参(会在页面中显示)
        this.$router.push({
            name:'index/${item.id}'
        })
        路由配置{path:'index:id'}
        this.$route.params.id

    query传参(可以解决页面刷新参数丢失的问题)(会在页面中显示)
        this.$router.push({
        name:'index'，
        query:{id:item.id}
        })
        this.$route.query.id

12.vue路由的hash模式和history模式有什么区别?
    1.hash的路由地址上有#号，history模式没有
    2.在做回车刷新的时候，hash模式会加载对应页面，history会报错484
    3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API
    4.hash不会重新加载页面，单页面应用必备
    5.history有历史记录，H5新增了pushstate和replacestate()去修改历史记录，并不会立刻发送请求
    6.history需要后台配置

13.路由拦截是怎么实现的?
    路由拦截 axios拦截需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截
    {
        name:'index',path:'/index',component:'Index',
        meta:{
        requireAuth:true(自定义字段)
        }
    }
        router.beforeEach((to,from,next)=>{
            if(to.meta.requietAuth){if( store.state.token ){
        next()}else{}
        }
        })

14.说一下vue的动态路由。
    要在路由配置里设置meta属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转

    根据用户登录的账号，返回用户角色
    前端再根据角色，跟路由表的meta.role进行匹配,把匹配搭配的路由形成可访问的路由      
    mutation，action提交，返回有权限的路由
    router.beforeEach配置
    页面，把拿到的路由传给子组件，子组件拿到值后渲染

15.如何解决刷新后二次加载路由?
    1.window.location.reload()
    2.matcher
    const router =createRouter()
    export function resetRouter(){
        const newRouter=creatRouter()
        router.matcher=newRouter.matcher
        }

16.vuex刷新数据会丢失吗?怎么解决?
    vuex肯定会重新获取数据，页面也会丢失数据（保存在运行内存里）
    1.把数据直接保存在浏览器缓存里(cookie localstoragesessionstorage)
    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法
    监听浏览器的刷新事件，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据

17.computed和watch的区别
    1.computed是计算属性, watch是监听, 监听的是data中数据的变化
    2.computed是支持缓存, 依赖的属性值发生变化, 计算属性才会重新计算, 否则用缓存;watch不支持缓存
    3.computed不支持异步, watch是可以异步操作
    4.computed是第一次加载就监听, watch是不监听
    5.computed函数中必须有return, watch不用

18.vuex在什么场景会去使用?属性有哪些?
    state       存储变量
    getters     state的计算属性
    mutations   提交更新数据的方法
    actions     和mutations差不多,提交mutations来修改数据,可以包括异步操作
    modules     模块化vuex
    使用场景:用户的个人信息、购物车模块、订单模块（数据量比较大的地方）

19.vue的双向数据绑定原理是什么?
    通过数据劫持和发布订阅者模式来实现，同时利用object.defineProperty()劫持各个属性的setter和getter，在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图是同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。
    第一步:需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter
    第二步:compi1e模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图
    第三步:Watcher订阅者是observer和Compile之间的通信桥梁，作用:
        1.在自身实例化的时候往订阅器内添加自己
        2.自身要有一个update()方法
        3.等待属性变动时，调用自身的update方法，触发compile这种的回调
    第四步:MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果

20.了解diff算法和虚拟DOM吗?
    虚拟DOM，描述元素和元素之间的关系，是对浏览器真实DOM轻量级可操作的内存中的表示，并非实际存在html树种的节点，以js对象形式存在，包含真实DOM的节点对应的属性和结构信息。
    
    创建一个JS对象，如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM
    步骤:
    1.创建
        JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面
    2.更新比较
        状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异
    3.更新真实dom
        把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。
        如果是静态页面，没有操作的话，虚拟dom要比真实dom性能消耗高
    优点：
        性能优化
        跨平台兼容
        易于实现组件化

    diff算法：
    vue实现响应式更新和高效性能优化的关键技术
        1.虚拟DOM比较
        2.同层级比较和优化策略
            同层比较
            双向遍历：在列表遍历更快找到，减少遍历次数
        3.三大核心操作
            移动节点：直接更新节点位置
            更新节点：内容发生改变，仅更新属性，不更换节点
            新增/删除节点：在DOM中相应新增或添加
        4.差异记录和批量更新
            等算法执行完成后，得到一份最小化差异集合，即待更新的真实DOM操作列表，随后vue一次性应用这些操作到DOM树上，大大降低DOM操作带来的性能损耗
    优势：
        在大量节点中快速定位差异，精准定位到需要更新的最小列表，避免了无效的重排与重绘


21.vue和jquery的区别是什么?
    1.原理不同
        vue就是数据绑定;jq是先获取dom再处理
    2.着重点不同
        vue是数据驱动，jq是着重于页面
    3.操作不同
        vue帮我们自动更新dom，jq需要先操作在处理
    4.未来发展不同

22.vuex的响应式处理。
    vuex是vue的状态管理工具vue中可以直接触发methods中的方法，vuex是不可以的。
    未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图
    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象
    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中

23.vue中遍历全局的方法有哪些?
    1.普通遍历，对象.forEach()
    arr.forEach(function(item,index,arr){
        console.log(item,index)
    })
    2.对元素统一操作 对象.map()
    var newarr = arr.map(function(item){return item+1})
    3.查找符合条件的元素 对象.filter()
    arr.filter(function(item){if(item>2){
        return false}else{
    return true}
        })
    4.查询符合条件的元素，返回索引 对象.findindex()
    arr.finindex(function(item){if(item>1){
        return true}else{return false}
        })
    对象.every()遇到不符合的对象会停止对象
    .some()找到符合条件的元素就止

24.如何搭建脚手架?
    下载:node cnpm webpack vue-cli创建项目:
    1.找到对应的文件，然后利用node指令创建(cmd)
    2.vue init webpack xxxx
    3.回车项目描述
    4.输入作者 回车
    5.选择vue build
    6.回车
    7.输入n
    8.不按照yarn
    9.输入npm run dev

25.如何封装一个组件?
    1.使用Vue.extend()创建一个组件
    2.使用Vue.components()方法注册组件
    3.如果子组件需要数据，可以在props中接收定义4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法原则:
    把功能拆开
    尽量让组件原子化，一个组件做一件事情容器组件管数据，展示组件管视图

26.封装一个可复用的组件，需要满足什么条件?
    1.低耦合，组件之间的依赖越小越好
    2.最好从父级传入信息，不要在公共组件中请求数据
    3.传入的数据要进行校验
    4.处理事件的方法写在父组件中

27.vue的过滤器怎么使用?
   vue的特性，用来对文本进行格式化处理使用它的两个地方，一个是插值表达式，一个是v-bind
   分类:
    1.全局过滤器
    Vue.filter('add',function(v){return v<10?'0'+v:v})
    `<div>{{33 add}}</div>`
    2.本地过滤器
    和methods同级
    filter:{add:function(v){return v<10?'0'+v:v}
    }

28.vue中如何做强制刷新?
    1.localtion.reload()
    2.this.$router.go(0)
    3.provide和inject

29.vue3和vue2有哪些区别?
    1.响应式原理不同
        vue2的双问数据绑定是利用ES5的一个APIObiect.defineProperty()对数据进行劫持 结合 发布订阅者模式的方式来实现的
        Vue3 中使用了 ES6 的 ProxyAP!对数据代理，通过 reactive() 函数给每一个对象都包一层 Proxy，通过 Proxy监听属性的变化，从而 实现对数据的监控
    相比于vue2版本，使用proxy的优势如下
        1.defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率(直接绑定整个对象即可)
        2.可以监听数组，不用再去单独的对数组做特异步操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美支持对数组的监听。
    2.实例化
        Vue2.x中new出的实例对象，所有的东西都在在个yue对象上，这样其实无论你用到不是没用到，都会跑一遍，这样不仅提高了性能消耗，也增加了用户加载时间。
        vue3.0中可以用ES module imports按需引入，如:keep-alive内置组件、v-mode|指令，等等，不仅我们开发起来更加的便捷，减少 了内存消耗，也同时减少了用户加载时间，优化用户体验。
    3.生命周期的不同
        vue3移除了beforcreate和created，引入setup，作为初始化核心，在组件实例创建前执行，并且可以直接访问响应式数据
        vue3 
        setup setup
        onBeforeMount onMounted
        onBeforeUpdate onUpdated
        onBeforeUnmount onUnmounted
    4.传值不同
        vue2的script代码可以直接获取props，$emit
        vue3需要通过setup指令传递
        props中数据流是单项的，即子组件不可改变父组件传来的值在组合式API中，如果想在子组件中用其它变量接收props的值时需要使用toRef将props中的属性转为响应式
        attrs和listeners子组件使用$attrs可以获得父组件除了props传递的属性和特性绑定属性(c1ass和 sty1e)之外的所有属性。子组件使用s1isteners可以获得父组件(不含.native修饰器的)所有v-on事件监听器，在vue3中已经不再使用;但是vue3中的attrs不仅可以获得父组件传来的属性也可以获得父组件v-on事件监听器
    5.定义数据变量方法不同
        vue2定义在data(){return{},}, methods{},
        vue3定义在setup中，并统一return
    6.API不同（选项式，选项式和组合式）
        vue2是选项式
        vue3是组合式
    7.是否支持碎片
        vue2支持单个根元素
        vue3引入fragment，支持多个根元素
    8.WatchEffect
        Vue3中除了watch，还引入了副作用监听函数watchEffect，用过之后我发现它和React中的useEffect很像，只不过watchEffect不需要传入依赖项。
    那么什么是watchEffect呢?
        watchEffect它会立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。
        computed和watch所依赖的数据必须是响应式的，Vue3引|入了watchEfect,watchEffect 相当于将 watch 的依赖源和回调函数合并，当任何你有用到的响应式依赖更新时，该回调函数便会重新执行。不同于 watch的是watchEffect的回调函数会被立即执行，即({immediate: true })。
    9.路由
        vue3的beforeRouteEnter作为路由守卫的示例是因为它在setup语法糖中是无法使用的;大家都知道setup中组件实例已经创建，是能够获取到组件实例的。
        beforeRouteEnter是再进入路由前触发的，此时组件还未创建，所以是无法用在setup中的;如果想在setup语法糖中使用则需要再写一个script, 在setup中包裹路由
    10.main.js不同（vue3使用工程函数）
    11.Vue3性能优化和模块化改进
        编译器优化
        更新组件渲染算法
        支持逻辑复用
    

30.vue的性能优化怎么做?
    1.编码优化
        不要把所有数据都放在data中
        v-for时给每个元素绑定事件用事件代理keep-alive缓存组件
        尽可能拆分组件，提高复用性、维护性
        key值要保证唯一
        合理使用路由懒加载，异步组件数据持久化存储的使用尽量用防抖、节流优化
    2.加载优化
        按需加载
        内容懒加载
        图片懒加载
    3.用户体验
        骨架屏
    4.SEO优化
        预渲染
        服务端渲染ssr
    5.打包优化
        CDN形式加载第三方模块
        多线程打包
        抽离公共文件
    6.缓存和压缩
        客户端缓存、服务端缓存
        服务端Gzip压缩

31.首屏优化该如何去做?
    1.使用路由懒加载
    2.非首屏组件使用异步组件
    3.首屏不中要的组件延迟加载
    4.静态资源放在CDN上
    5.减少首屏上JS、CSS等资源文件的大小
    6.使用服务端渲染
    7.简历减少DOM的数量和层级
    8.使用精灵图请求
    9.做一些loading
    10.开启Gzip压缩
    11.图片懒加载

32.vue3的性能为什么比vue2好?
    1.diff算法的优化
    2.静态提升
    3.事件侦听缓存
    4.ssr渲染
    5.更好的Ts支持

33.vue3为什么使用proxy?
    1.proxy可以代理整个对象，defineProperty只代理对象上的某个属性
    2.proxy对代理对象的监听更加丰富
    3.proxy代理对象会生成新的对象，不会修改被代理对象本身
    4.proxy不兼容IE浏览器

34.说一下你对组件的理解。
    可以重复使用的vue实例，独一无二的组件名称
    可以抽离单独的公共模块
    提高代码的复用率

35.你是如何规划项目文件的?
    public
        图标、index.html、img
    src
        api
        assets 
        components
            按分类再次划分子目录
        plugins
        router
        static
        styles
        utils
        views
    App.vue
    main.js
    package.json
    vue.config.js
36.是否使用过nuxt.js?
    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置
    SSR:服务端渲染
    好处:
        SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索
        优化了首屏加载时间
    SEO:优化搜索引擎
        SPA的应用不利于搜索引擎SEO的操作

37.SEO如何优化?
    1.SSR
    2.预渲染 prerender-spa-plugin

38.vue的响应式原理
    1.数据劫持
        vue2:object.defineProperty()
        getter setter
    2.观察者模式
    3.依赖收集
        Dependents
    4.更新视图
    vue3升级
        proxy取代了object.defineProperty()

39.vue的双向数据绑定原理
    vue2的双向数据绑定原理
        1.数据劫持
        2.观察者模式
        3.依赖收集
        4.视图更新
    vue3的双向数据绑定原理
        1.proxy代理
        2.响应式系统
        3.effect hook

40.Vue的key值
    1.唯一标识和节点映射
        key充当唯一标识符，为v-for循环或者其他动态生成的节点提供了稳定的表识，通过key准确定位追踪节点，可以通过key判断加入，移动或移除的节点，从而有效维持DOM结构和数据模型的映射关系
    2.提升DOM更新性能
        对比新旧虚拟DOM树时，key的存在能更快速地进行判断节点的状态，进而针对性进行操作，提升大型列表场景下的渲染性
    3.动画过渡和元素复用
        带有key值的元素在切换，插入，删除时，vue能够精准定位执行过渡效果时，同时会尝试复用相同key值不同渲染状态下位置有所变动的元素。
    4.避免渲染错误和警告
        相同父元素下，保证key值唯一，否则可能出现错误

    面试：key作用+虚拟DOM+diff算法

    key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能。
    当data发生变化的时候,Vue会使用diff算法来对比新旧虚拟dom，如果key值相同,才会考虑复用元素。如果key值不同,则会强制更新元素一般通过给元素key值设置为id,来保证Vue在更新数据的时候可以最大限度复用相同key值的元素
    key值为什么不能是下标:
    因为数组的长度发生变化的时候，其他的元素下标会受到影响。而如果把下标作为key值，由于其他的元素下标变化。所以vue会认为你的key值也变化了，就会强制更新你的元素，影响性能

41.vue组件在初始化的时候会执行那些生命周期函数
    beforecreate
        第一步，组件实例被创建，但是vue还没有初始化它的属性和方法data,computed，methods是不可以用的
    created
        实例初始化，可以访问data,computed，methods中的数据和函数此时DOM还没有生成可以执行异步数据获取其他不需要依赖真实DOM的操作
    beforeMount
        组件模板编译好，挂载到DOM树之前虚拟DOM创建，没有渲染到页面上
    mounted
        组件真实DOM渲染出来，DOM的所有操作都可以执行完全初始化并可以和用户界面进行交互

42.vue父子组件在初始化的时候，生命周期函数如何执行
    顺序：
        父beforecreate
        父created
        父beforeMount
            子的beforecreate
            子的created
            子的beforeMount
            子的mounted
        父mounted

43.vue里如何在created中操作DOM
    $nextTick()
    export default{
        created(){
            this.$nextTick(()=>{
                const ele = this.$refs.xxx})
        }
    }

44.vue中数据更新视图不更新，是什么原因?怎么解决?
    1.未在响应式对象上进行数据修改
        this.$set(vue2.x)
        在响应式对象上调用属性赋值 vue3.x
    2.未使用正确的引用更新数组
        push pop shift splice
    3.作用域问题
        确保在正确上下文更新数据
    4.vue实例未正确创建和更新
        在适当的生命钩子中调用
    5.未使用v-bind或:绑定

45.Vue3的hooks
    hook是钩子的意思，hooks 就是函数的一种写法。
    vue3 借鉴 react hooks 开发出了 composition API ，所以也就意味着Composition API 也可以进行自定义封装 hooks。
    vue3 中的 hooks 就是函数的一种写法，就是将文件的一些单独功能的is代码进行抽离出来，放到单独的is文件中，或者说是一些可以复用的公共方法/功能。其实 hooks和 vue2 中的 mixin 有点类似，但是相对 mixins 而言， hooks更清楚复用功能代码的来源，更清晰易懂。

46.vue3+vite项目打包优化
    优化方案:
        1.build 视图分析依赖文件
        2.第三方库CDN引入
            CDN 是构建在数据网络上的一种分布式的内容分发网。
            CDN的作用是采用流媒体服务器集群技术，克服单机系统输出带宽及并发能力不足的缺点，可极大提升系统支持的并发流数目，减少或避免单点失效带来的不良影响。
        3.依赖文件分包,
        4.gzip压缩文件
        5.部署前配置history路由模式的404问题

47.自定义指令
    directive里面添加方法， v-方法名= 'name'进行绑定

48.路由二次封装
    把routes和路由守卫拿出来
    1.提取到文件夹里，新建js，export default
    2.在index引入，把路径挂载到VueRouter的routes对象上面
    3.新建js，把beforeEach和affterEach两个导航守卫放里面
    4.在index引入，通过路由对象router.beforeEach进行使用

49.Vue3组件通信
    1.props
        props 是vue 中最常见的父子通信方式，使用起来也比较简单。
        根据demo，我们在父组件中定义了数据和对数据的操作，子组件只渲染一个列表。
    2.emit
        Emit也是vue中最常见的组件通信方式，用于子组件向父组件传递消息。我们在父组件中定义列表，子组件只需要传递添加的值。点击子组件中的【添加】按钮后，我们会发出一个自定义事件，并将添加的值作为参数传递给父组件。
    3.v-model
        v-mode1 是 Vue 中一个优秀的语法糖，比如下面的代码。<Childcomponent v-model:title="pageTitle"/>
        这是以下代码的简写形式
        <Childcomponent :title="pageTitle" @update:title="pageTitle =$event" />
        在子组件中，我们先定义props和emits，添加完成后再发出指定的事件。
        注意:update:*是vue中固定的写法，*代表props中的一个属性名。
    4.refs
        使用API选项时，我们可以通过this.srefs.name获取指定的元素或组件，但在组合API中不行。如果我们想通过ref获取，需要定义一个同名的Ref对象，在组件挂载后可以访问。
        注意:默认情况下，setup 组件是关闭的，通过模板ref获取组件的公共实例。如果需要公开，需要通过defineExpose API 公开。
    5.provide/inject
        provide/inject是 vue 中提供的一对 API。无论层级多深，API 都可以实现父组件到子组件的数据传递。
        注意:使用 provide 进行数据传输时，尽量使用readonly 封装数据，避免子组件修改父组件传递的数据。
    6.eventBus
        Vue 3 中移除了 eventBus，但可以借助第三方工具来完成。vue 官方推荐使用mitt 或tiny-emitter。
        在大多数情况下，不建议使用全局事件总线来实现组件通信。虽然比较简单粗暴，但是维护事件总线从长远来看是个大问题，这里就不解释了。有关详细信息，您可以阅读特定工具的文档。
    7.vuex/pinia
        vuex和 Pinia是 vue 3 中的状态管理工具，使用这两个工具可以轻松实现组件通信。

50.VUe的全局混入和prototype
    mixins是直接复制到vue实例对象上
            this.xxx()this.obj.aaa()
                Vue .mixin({
                    methods:{
                        xxx()}
                        })
    vue.prototype是直接在原型上添加方法
        Vue.prototype.xxx()

51.Vuex和pinia
    Vuex有5个属性
        state:{
        msg:'vuex数据}，
        getters:{}，
        mutations:{}，处理同步
        actions:{}，处理异步
        modules:{}
    使用：$store,或者map函数
    Pinia有三个属性
        state()=>{return{msg:'',}
        }
        getters:{},
        actions{} 处理同步和异步
    使用:先引入文件，拿到实例，解构进行使用

52.Vue的slot
    匿名插槽
    具名插槽（可以改变位置）
    作用域插槽（可以传值）

53.异步组件
    1、异步组件是 vue 的一种优化方法，比如可以运用在首屏加载等场景。
    2、异步组件可以减少打包的结果，会将异步组件分开打包，会采用异步的方式加载组件，可以有效的解决一个组件过大的问题。不使用异步组件，如果组件功能比较多打包出来的结果就会变大。
    3、异步组件的核心可以给组件定义变成一个函数，函数里面可以用import语法，实现文件的分割加载。

    defineAsynccomponent方法也可以接收一个对象作为参数，该对象中有如下几个参数:
    loader:同工厂函数:
    loadingcomponent:加载异步组件时展示的组件
    errorcomponent:加载组件失败时展示的组件
    delay:显示loadingcomponent之前的延迟时间，单位秒，默认288毫秒
    timeout:如果提供了timeout，并且加载组件的时间超过了设定值，将显示错误组件，默认值为Infinity(单位毫秒);
    suspensible:异步组件可以退出<Suspense>控制，并始终控制自己的加载状态。具体可以参考文档;
    onError:一个函数，该函数包含4个参数，分别是error、retry、fai1和attempts，这4个参数分别是错误对象、重新加载的函数
    加载程序结束的函数、已经重试的次数

54.excel导出
    1.引入vue-json-excel   
        使用download-excel
    2.引入file-saver xlsx  
        使用xlsx获取二进制字符，然后file-saver保存blob文件

55.导入excel
    1. elementui和xlsx
        el-upload上传， filereader读取
    2.  input标签上传文件，filereader.onload读取json文件

56.分片导出excel数据
    1. mock.js和file-saver
    2. 分片处理，循环存入数组
    3. blob文件，filesaver存入

57.虚拟列表
    数据过大渲染会导致性能下降
    1.在components中创建一个List.vue组件，他是用来展示虚拟列表。
    2.把List.vue组件引入到页面中。
    3.在主页面模拟一万条数据，传给子组件
    4.List组件接值，然后搭建
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png">
    <List :items="items" :size="60" :shownumber="10" />
  </div>
</template>

<script>
import List from '@/components/List.vue';

export default {
  name: 'HomeView',
  components: {
    List
  },
  computed: {
    // 要进行渲染的数据列表
    items() {
      // 模拟一万条数据，将内容填充
      return Array(10000).fill().map((item, index) => ({
        id: index,
        content: '列表数据内容：' + index
      }));
    }
  }
};
</script>
<!-- List -->
<template>
  <div class="containen" :style="{ height: containerHeight }" @scroll="handleScroll" ref="container">
    <!-- 数据列表 -->
    <div class="list" :style="{ top: listTop + 'px' }"> <!-- 注意：这里添加了 'px' 以确保样式正确应用 -->
      <!-- 列表项 -->
      <div v-for="item in showData" :key="item.id" :style="{ height: size + 'px' }">
        {{ item.content }}
      </div>
      <!-- 用于撑开高度的元素（通常这个元素是隐藏的，仅用于触发滚动事件的计算）-->
      <div class="ban" :style="{ height: (items.length * size) + 'px' }" v-if="false"></div> <!-- 注意：这里修改了 barHeight 的逻辑，但通常这个元素是隐藏的，所以我用 v-if="false" 来隐藏它 -->
      <!-- 注意：如果 barHeight 是用于其他目的（不是隐藏元素），请根据需要调整其逻辑 -->
    </div>
  </div>
</template>

<script>
export default {
  name: 'List',
  props: {
    // 要渲染的数据
    items: {
      type: Array,
      required: true
    },
    // 每条数据渲染节点的高度
    size: {
      type: Number,
      required: true
    },
    // 每次渲染DOM节点个数
    shownumber: {
      type: Number,
      required: true
    }
  },
  data() {
    return {
      start: 0, // 要展示数据的起始下标
      end: this.shownumber // 要展示数据的结束下标
    };
  },
  computed: {
    // 最终筛选出要展示的数据
    showData() {
      return this.items.slice(this.start, this.end);
    },
    // 容器的高度（通常这个高度是固定的，等于每次展示的数据条数乘以每条数据的高度）
    containerHeight() {
      return this.size * this.shownumber + 'px';
    },
    // 列表项上滚动改变 top 的值（这个值用于设置 .list 元素的 top 样式，以实现滚动效果）
    listTop() {
      return this.start * this.size + 'px';
    }
    // 注意：barHeight 在这个例子中可能不是必需的，因为它通常用于隐藏元素来触发滚动事件。
    // 如果您的设计中确实需要 barHeight，请根据您的具体需求来调整其计算逻辑。
  },
  methods: {
    // 容器的滚动事件
    handleScroll() {
      // 1. 获取容器顶部滚动的尺寸
      const scrollTop = this.$refs.container.scrollTop;
      // 计算卷去的数据条数，用计算的结果作为获取数据的起始和结束下标
      // 起始的下标就是卷去的数据条数（向上取整，因为滚动可能不完全对齐到单条数据的高度）
      // 但为了简化，这里使用向下取整，这可能导致在滚动到边界时显示不完全的一条数据
      // 根据需要，您可以调整为 Math.ceil(scrollTop / this.size) 或其他逻辑
      this.start = Math.floor(scrollTop / this.size);
      // 结束的下标就是起始的下标加上要展示的数据条数
      this.end = this.start + this.shownumber;
      // 注意：这里可能需要添加一些边界检查，以确保 start 和 end 不会超出 items 数组的范围
      // 例如：this.start = Math.max(0, Math.min(this.items.length - this.shownumber, this.start));
      // 和 this.end = this.start + this.shownumber; （这行代码其实已经足够，因为 start 已经被限制了）
    }
  }
};
</script>

<style scoped>
/* 添加一些基本的样式 */
.containen {
  overflow-y: auto; /* 允许垂直滚动 */
  position: relative; /* 为 .list 设置 top 样式时，需要相对定位 */
}
.list {
  position: absolute; /* 使用绝对定位，以便通过 top 样式来控制其位置 */
  width: 100%; /* 根据需要调整宽度 */
}
.ban {
  /* 这个类通常用于隐藏元素，仅用于触发滚动事件的计算 */
  /* 如果不需要，可以删除这个类和相关的 HTML 元素 */
}
</style>

58.vue2的Object.defineProperty和vue3的Proxy区别
    一、defineProperty 是对属性拦截，proxy 是对代理对象
    defineProperty
        只能拦截对象的某一个属性，不能对整个对象进行拦截，如果需要监听一个对象的所有属性，需要遍历对象的所有属性并对其进行拦截来实现监听。
    proxy
        设置代理对象的属性后，原始对象和代理对象都发生了变化，但是获取原始对象的属性不会触发getter，只有访问代理对象的属性才能触发getter。
    二、defineProperty无法监听对象新增属性，proxy可以
        根据他们的监听方式的不同我们就知道，当对象新增属性的时候，defineProperty没有对新增的属性进行拦截，自然就不会监听到对象新增的属性变化。而proxy是对对象进行代理，自然就能监听到对象属性的新增。
    三、defineProperty也无法监听对象删除属性，proxy可以
        proxy有专门针对属性删除的办法deleteProperty，可以在对象属性被删除时触发。
        
    四、defineProperty不能监听数组下标改变值的变化，proxy 可以且不需要对数组的方法进行重写
    数组的 key 就是数组的索引。
    问题是:数组的 push、pop、shift、unshift、splice、sort，reverse是无法触发 set 方法的,
    五、defineProperty性能较差
        defineProperty 是循环遍历对象属性的方式来进行监听，自然会比 proxy对整个对象进行监听的方式要耗性能。另外Proxy的拦截也是懒处理行为，如果用户没有访问嵌套对象，那么也不会实施拦截，这就让初始化的速度和内存占用都改善了。

59.vue项目中，更新了数据，但是视图没更新点击”改变”，视图发生更新
    点击“添加”，视图未更新，其实数据已经更新，只是视图没有改变vue2中响应式的核心是Object.defineProperty如果想要触发响应式(视图)更新，要确保对象的属性触发响应式确保改变对象属性是对象已经有的属性，才能监听到响应式做添加、删除操作对象属性，响应式无法监听到
    解决办法一:
    使用Vue.set/Vue.delete
        // 添加对象方法
        this.$set(this.obj, 'e', '5’)删除类似，不再整述
    方法二:
        使用vm.$forceUpdate强制更新视图
        this.obi.d ='4'
        // 对视图进行强制更新
        this.$forceUpdate()
    方法三:
        使用深拷贝，重新赋值替换
        只要改变对象不是同一个对象即可
        重新赋值，不是同一对象，这样才能触发响应式
        const obj=jsoN.parseJSON.stringify(this.obj)
        obj.e = '5'
        this.obj= obj
        对于数组，可以使用slice、concat等方法

60.vue的$nextTick原理
    vue 实现响应式并不是数据发生变化后 DOM 立即变化，而是按照一定策略异步执行 DOM 更新的vue 在修改数据后，视图不会立刻进行更新，而是要等同一事件循环机制内所有数据变化完成后，再统-进行DOM更新
    nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
    事件循环机制:
        在浏览器环境中，我们可以将我们的执行任务分为宏任务和微任务
        宏任务:包括整体代码script，setTimeout，setlnterval、setlmmediate
        微任务:Promise.then、Promise.all
    Vue.nextTick原理
        Vue中 数据变化 => DOM变化 是异步过程，一旦观察到数据变化，Vue就会开启一个任务队列，然后把在同一个事件循环(Event loop)中观察到数据变化的 Watcher (Vue源码中的Wacher类是用来更新Dep类收集到的依赖的)推送进这个队列。
        如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
        nextTick的作用是为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback)，JS是单线程的，拥有事件循环机制，nextTick的实现就是利用了事件循环的宏任务和微任务。

    nextTick的调用方式:
    1.回调函数方式:Vue.nextTick(ca11back)
    2.Promise方式:Vue.nextTick().then(ca11back)
    3.实例方式:vm.$nextTick(ca11back)

    Vue.nextTick的应用
    1、created生命周期中操作DOM
        created钩子函数执行的时候DOM 其实并未进行挂载和渲染，此时就是无法操作DOM的，我们将操作DOM的代码中放到nextTick中，等待下一轮事件循环开始，DOM就已经进行挂载好了，而与这个操作对应的就是mounted钩子函数，因为在mounted执行的时候所有的DOM挂载已完成。
    2、修改数据，获取DOM值
        当我们修改了data里的数据时，并不能立刻通过操作DOM去获取到里面的值

61.Vue中computed实现缓存的原理
    computed是响应式的
        读取computed时就会触发get，设置的时候会触发set
    computed是如何控制缓存
        某个计算属性C依赖data中的A，如果没有缓存，每次读取c的时候，C都会去读取A，就会触发A的get，多次触发A的get是会很消耗性能的，所以computed必须缓存脏数据标记:dirty，是watcher的属性
        dirty是true时，读取computed值时重新计算dirty是false时，读取computed值时会使用缓存
    依赖的data发生改变，，computed时如何更新页面P中的计算属性C，依赖于data里的A，computed的更新步骤:
        1.因为C依赖于A，所以A可以收集到c的watcher
        2.当A发生改变，会把watcher的dirty设置为true
        3.A还会手机页面P的watcher，A会通知P进行更新，页面P重新读取计算属性C，因为此时的dirty是true，所以此时的计算属性要重新计算
        4.computed更新完之后，会把dirty设置成false，如果依赖的A不发生变化，那么下次就会读取缓存

五、Echarts
1.echarts有用过吗?常用的组件有哪些?
    title标题组件 show text linktoolbox
    工具栏 导出图片 数据视图 切换 缩放 show orient feature
    tooltip trigger 触发类型
    markPoint   标注点
    markLine    图标的标线

六、Weabpack
1.webpack打包和不打包的区别?
    1.运行效率
    2.对基础的支持不够（浏览器支持，比如es6）

2.webpack是怎么打包的，babel是做什么的?
    webpack会把js css image看作一个模块，用import/require引入
    找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起
    把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件
    如果一个被多个文件引用，打包时只会生成一个文件
    如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包
    对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中

七、Git
1.git如何合并、拉取代码?
    拉取代码 git pull 仓库地址
    查看状态 git sattus
    提交到本地缓存区 git add.
    提交本地仓库 git commit -m'修改描述
    提交到远程仓库 git push 仓库地址 master
    创建分支 git branch -b xxx
    合并分支 git merge'合并分支的名字

2.git如何解决冲突问题?
    1.两个分支中修改了同一个文件
    2.两个分支中修改了同一个文件的名字
    1.解决:当前分支上，直接修改代码addcommit
    2.解决:在本地当前分支上，修改冲突代码add commit push

八、HR
1.你的离职原因是什么?
    社保  薪资  个人发展  技术提升  家庭因素

2.工作到现在，项目中遇到最难的问题是什么?怎么解决的?
    1. 不要回答没有
    2. 不要说一些常见的简单问题，比如：数据请求不过来，渲染页面时出现了问题，跳转路由不会...
    3.最好是逻辑上
    首先是自行查找资料寻求解决办法，然后再去请教同时或者组长

3.你的优势在哪里?
    1.尽量不要暴露自己的缺点
    2.不要过度美化自己

4.如何协同工作?
    1.开发前会开个会议，最后会形成一个开发文档
    2.利用工具保证项目的正常进度，规范化